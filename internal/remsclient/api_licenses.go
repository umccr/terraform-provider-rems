/*
REMS API

REMS API Services

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package remsclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// LicensesAPIService LicensesAPI service
type LicensesAPIService service

type ApiApiLicensesAddAttachmentPostRequest struct {
	ctx         context.Context
	ApiService  *LicensesAPIService
	xRemsApiKey *string
	xRemsUserId *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiLicensesAddAttachmentPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiLicensesAddAttachmentPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiLicensesAddAttachmentPostRequest) XRemsUserId(xRemsUserId string) ApiApiLicensesAddAttachmentPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiLicensesAddAttachmentPostRequest) Execute() (*AddLicenseAttachmentResponse, *http.Response, error) {
	return r.ApiService.ApiLicensesAddAttachmentPostExecute(r)
}

/*
ApiLicensesAddAttachmentPost Add an attachment file that will be used in a license (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiLicensesAddAttachmentPostRequest
*/
func (a *LicensesAPIService) ApiLicensesAddAttachmentPost(ctx context.Context) ApiApiLicensesAddAttachmentPostRequest {
	return ApiApiLicensesAddAttachmentPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AddLicenseAttachmentResponse
func (a *LicensesAPIService) ApiLicensesAddAttachmentPostExecute(r ApiApiLicensesAddAttachmentPostRequest) (*AddLicenseAttachmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddLicenseAttachmentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LicensesAPIService.ApiLicensesAddAttachmentPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/licenses/add_attachment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiLicensesArchivedPutRequest struct {
	ctx             context.Context
	ApiService      *LicensesAPIService
	archivedCommand *ArchivedCommand
	xRemsApiKey     *string
	xRemsUserId     *string
}

func (r ApiApiLicensesArchivedPutRequest) ArchivedCommand(archivedCommand ArchivedCommand) ApiApiLicensesArchivedPutRequest {
	r.archivedCommand = &archivedCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiLicensesArchivedPutRequest) XRemsApiKey(xRemsApiKey string) ApiApiLicensesArchivedPutRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiLicensesArchivedPutRequest) XRemsUserId(xRemsUserId string) ApiApiLicensesArchivedPutRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiLicensesArchivedPutRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiLicensesArchivedPutExecute(r)
}

/*
ApiLicensesArchivedPut Archive or unarchive license (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiLicensesArchivedPutRequest
*/
func (a *LicensesAPIService) ApiLicensesArchivedPut(ctx context.Context) ApiApiLicensesArchivedPutRequest {
	return ApiApiLicensesArchivedPutRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *LicensesAPIService) ApiLicensesArchivedPutExecute(r ApiApiLicensesArchivedPutRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LicensesAPIService.ApiLicensesArchivedPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/licenses/archived"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.archivedCommand == nil {
		return localVarReturnValue, nil, reportError("archivedCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.archivedCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiLicensesAttachmentsAttachmentIdGetRequest struct {
	ctx          context.Context
	ApiService   *LicensesAPIService
	attachmentId int64
	xRemsApiKey  *string
	xRemsUserId  *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiLicensesAttachmentsAttachmentIdGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiLicensesAttachmentsAttachmentIdGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiLicensesAttachmentsAttachmentIdGetRequest) XRemsUserId(xRemsUserId string) ApiApiLicensesAttachmentsAttachmentIdGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiLicensesAttachmentsAttachmentIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiLicensesAttachmentsAttachmentIdGetExecute(r)
}

/*
ApiLicensesAttachmentsAttachmentIdGet Get a license's attachment (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param attachmentId attachment id
	@return ApiApiLicensesAttachmentsAttachmentIdGetRequest
*/
func (a *LicensesAPIService) ApiLicensesAttachmentsAttachmentIdGet(ctx context.Context, attachmentId int64) ApiApiLicensesAttachmentsAttachmentIdGetRequest {
	return ApiApiLicensesAttachmentsAttachmentIdGetRequest{
		ApiService:   a,
		ctx:          ctx,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *LicensesAPIService) ApiLicensesAttachmentsAttachmentIdGetExecute(r ApiApiLicensesAttachmentsAttachmentIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LicensesAPIService.ApiLicensesAttachmentsAttachmentIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/licenses/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiLicensesCreatePostRequest struct {
	ctx                  context.Context
	ApiService           *LicensesAPIService
	createLicenseCommand *CreateLicenseCommand
	xRemsApiKey          *string
	xRemsUserId          *string
}

func (r ApiApiLicensesCreatePostRequest) CreateLicenseCommand(createLicenseCommand CreateLicenseCommand) ApiApiLicensesCreatePostRequest {
	r.createLicenseCommand = &createLicenseCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiLicensesCreatePostRequest) XRemsApiKey(xRemsApiKey string) ApiApiLicensesCreatePostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiLicensesCreatePostRequest) XRemsUserId(xRemsUserId string) ApiApiLicensesCreatePostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiLicensesCreatePostRequest) Execute() (*CreateLicenseResponse, *http.Response, error) {
	return r.ApiService.ApiLicensesCreatePostExecute(r)
}

/*
ApiLicensesCreatePost Create license (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiLicensesCreatePostRequest
*/
func (a *LicensesAPIService) ApiLicensesCreatePost(ctx context.Context) ApiApiLicensesCreatePostRequest {
	return ApiApiLicensesCreatePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CreateLicenseResponse
func (a *LicensesAPIService) ApiLicensesCreatePostExecute(r ApiApiLicensesCreatePostRequest) (*CreateLicenseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateLicenseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LicensesAPIService.ApiLicensesCreatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/licenses/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLicenseCommand == nil {
		return localVarReturnValue, nil, reportError("createLicenseCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.createLicenseCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiLicensesEnabledPutRequest struct {
	ctx            context.Context
	ApiService     *LicensesAPIService
	enabledCommand *EnabledCommand
	xRemsApiKey    *string
	xRemsUserId    *string
}

func (r ApiApiLicensesEnabledPutRequest) EnabledCommand(enabledCommand EnabledCommand) ApiApiLicensesEnabledPutRequest {
	r.enabledCommand = &enabledCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiLicensesEnabledPutRequest) XRemsApiKey(xRemsApiKey string) ApiApiLicensesEnabledPutRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiLicensesEnabledPutRequest) XRemsUserId(xRemsUserId string) ApiApiLicensesEnabledPutRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiLicensesEnabledPutRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiLicensesEnabledPutExecute(r)
}

/*
ApiLicensesEnabledPut Enable or disable license (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiLicensesEnabledPutRequest
*/
func (a *LicensesAPIService) ApiLicensesEnabledPut(ctx context.Context) ApiApiLicensesEnabledPutRequest {
	return ApiApiLicensesEnabledPutRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *LicensesAPIService) ApiLicensesEnabledPutExecute(r ApiApiLicensesEnabledPutRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LicensesAPIService.ApiLicensesEnabledPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/licenses/enabled"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enabledCommand == nil {
		return localVarReturnValue, nil, reportError("enabledCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.enabledCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiLicensesGetRequest struct {
	ctx         context.Context
	ApiService  *LicensesAPIService
	xRemsApiKey *string
	xRemsUserId *string
	disabled    *bool
	archived    *bool
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiLicensesGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiLicensesGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiLicensesGetRequest) XRemsUserId(xRemsUserId string) ApiApiLicensesGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

// whether to include disabled licenses
func (r ApiApiLicensesGetRequest) Disabled(disabled bool) ApiApiLicensesGetRequest {
	r.disabled = &disabled
	return r
}

// whether to include archived licenses
func (r ApiApiLicensesGetRequest) Archived(archived bool) ApiApiLicensesGetRequest {
	r.archived = &archived
	return r
}

func (r ApiApiLicensesGetRequest) Execute() ([]License, *http.Response, error) {
	return r.ApiService.ApiLicensesGetExecute(r)
}

/*
ApiLicensesGet Get licenses (roles: handler, organization-owner, owner, reporter)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiLicensesGetRequest
*/
func (a *LicensesAPIService) ApiLicensesGet(ctx context.Context) ApiApiLicensesGetRequest {
	return ApiApiLicensesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []License
func (a *LicensesAPIService) ApiLicensesGetExecute(r ApiApiLicensesGetRequest) ([]License, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []License
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LicensesAPIService.ApiLicensesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.disabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disabled", r.disabled, "", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiLicensesLicenseIdGetRequest struct {
	ctx         context.Context
	ApiService  *LicensesAPIService
	licenseId   int64
	xRemsApiKey *string
	xRemsUserId *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiLicensesLicenseIdGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiLicensesLicenseIdGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiLicensesLicenseIdGetRequest) XRemsUserId(xRemsUserId string) ApiApiLicensesLicenseIdGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiLicensesLicenseIdGetRequest) Execute() (*License, *http.Response, error) {
	return r.ApiService.ApiLicensesLicenseIdGetExecute(r)
}

/*
ApiLicensesLicenseIdGet Get license (roles: handler, organization-owner, owner, reporter)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param licenseId license id
	@return ApiApiLicensesLicenseIdGetRequest
*/
func (a *LicensesAPIService) ApiLicensesLicenseIdGet(ctx context.Context, licenseId int64) ApiApiLicensesLicenseIdGetRequest {
	return ApiApiLicensesLicenseIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		licenseId:  licenseId,
	}
}

// Execute executes the request
//
//	@return License
func (a *LicensesAPIService) ApiLicensesLicenseIdGetExecute(r ApiApiLicensesLicenseIdGetRequest) (*License, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *License
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LicensesAPIService.ApiLicensesLicenseIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/licenses/{license-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"license-id"+"}", url.PathEscape(parameterValueToString(r.licenseId, "licenseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiLicensesRemoveAttachmentPostRequest struct {
	ctx          context.Context
	ApiService   *LicensesAPIService
	attachmentId *int64
	xRemsApiKey  *string
	xRemsUserId  *string
}

// attachment id
func (r ApiApiLicensesRemoveAttachmentPostRequest) AttachmentId(attachmentId int64) ApiApiLicensesRemoveAttachmentPostRequest {
	r.attachmentId = &attachmentId
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiLicensesRemoveAttachmentPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiLicensesRemoveAttachmentPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiLicensesRemoveAttachmentPostRequest) XRemsUserId(xRemsUserId string) ApiApiLicensesRemoveAttachmentPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiLicensesRemoveAttachmentPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiLicensesRemoveAttachmentPostExecute(r)
}

/*
ApiLicensesRemoveAttachmentPost Remove an attachment that could have been used in a license. (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiLicensesRemoveAttachmentPostRequest
*/
func (a *LicensesAPIService) ApiLicensesRemoveAttachmentPost(ctx context.Context) ApiApiLicensesRemoveAttachmentPostRequest {
	return ApiApiLicensesRemoveAttachmentPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *LicensesAPIService) ApiLicensesRemoveAttachmentPostExecute(r ApiApiLicensesRemoveAttachmentPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LicensesAPIService.ApiLicensesRemoveAttachmentPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/licenses/remove_attachment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.attachmentId == nil {
		return localVarReturnValue, nil, reportError("attachmentId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "attachment-id", r.attachmentId, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
