/*
REMS API

REMS API Services

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package remsclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ApplicationsAPIService ApplicationsAPI service
type ApplicationsAPIService service

type ApiApiApplicationsAcceptInvitationPostRequest struct {
	ctx             context.Context
	ApiService      *ApplicationsAPIService
	invitationToken *string
	xRemsApiKey     *string
	xRemsUserId     *string
}

// invitation token
func (r ApiApiApplicationsAcceptInvitationPostRequest) InvitationToken(invitationToken string) ApiApiApplicationsAcceptInvitationPostRequest {
	r.invitationToken = &invitationToken
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsAcceptInvitationPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsAcceptInvitationPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsAcceptInvitationPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsAcceptInvitationPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsAcceptInvitationPostRequest) Execute() (*AcceptInvitationResult, *http.Response, error) {
	return r.ApiService.ApiApplicationsAcceptInvitationPostExecute(r)
}

/*
ApiApplicationsAcceptInvitationPost Accept an invitation by token (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsAcceptInvitationPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsAcceptInvitationPost(ctx context.Context) ApiApiApplicationsAcceptInvitationPostRequest {
	return ApiApiApplicationsAcceptInvitationPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AcceptInvitationResult
func (a *ApplicationsAPIService) ApiApplicationsAcceptInvitationPostExecute(r ApiApiApplicationsAcceptInvitationPostRequest) (*AcceptInvitationResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AcceptInvitationResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsAcceptInvitationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/accept-invitation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.invitationToken == nil {
		return localVarReturnValue, nil, reportError("invitationToken is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "invitation-token", r.invitationToken, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsAcceptLicensesPostRequest struct {
	ctx                   context.Context
	ApiService            *ApplicationsAPIService
	acceptLicensesCommand *AcceptLicensesCommand
	xRemsApiKey           *string
	xRemsUserId           *string
}

func (r ApiApiApplicationsAcceptLicensesPostRequest) AcceptLicensesCommand(acceptLicensesCommand AcceptLicensesCommand) ApiApiApplicationsAcceptLicensesPostRequest {
	r.acceptLicensesCommand = &acceptLicensesCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsAcceptLicensesPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsAcceptLicensesPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsAcceptLicensesPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsAcceptLicensesPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsAcceptLicensesPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsAcceptLicensesPostExecute(r)
}

/*
ApiApplicationsAcceptLicensesPost Submit a `accept-licenses` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsAcceptLicensesPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsAcceptLicensesPost(ctx context.Context) ApiApiApplicationsAcceptLicensesPostRequest {
	return ApiApiApplicationsAcceptLicensesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsAcceptLicensesPostExecute(r ApiApiApplicationsAcceptLicensesPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsAcceptLicensesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/accept-licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.acceptLicensesCommand == nil {
		return localVarReturnValue, nil, reportError("acceptLicensesCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.acceptLicensesCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsAddAttachmentPostRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	applicationId *int64
	xRemsApiKey   *string
	xRemsUserId   *string
}

// application id
func (r ApiApiApplicationsAddAttachmentPostRequest) ApplicationId(applicationId int64) ApiApiApplicationsAddAttachmentPostRequest {
	r.applicationId = &applicationId
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsAddAttachmentPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsAddAttachmentPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsAddAttachmentPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsAddAttachmentPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsAddAttachmentPostRequest) Execute() (*SaveAttachmentResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsAddAttachmentPostExecute(r)
}

/*
ApiApplicationsAddAttachmentPost Add an attachment file related to an application (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsAddAttachmentPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsAddAttachmentPost(ctx context.Context) ApiApiApplicationsAddAttachmentPostRequest {
	return ApiApiApplicationsAddAttachmentPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SaveAttachmentResponse
func (a *ApplicationsAPIService) ApiApplicationsAddAttachmentPostExecute(r ApiApiApplicationsAddAttachmentPostRequest) (*SaveAttachmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SaveAttachmentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsAddAttachmentPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/add-attachment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationId == nil {
		return localVarReturnValue, nil, reportError("applicationId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "application-id", r.applicationId, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsAddLicensesPostRequest struct {
	ctx                context.Context
	ApiService         *ApplicationsAPIService
	addLicensesCommand *AddLicensesCommand
	xRemsApiKey        *string
	xRemsUserId        *string
}

func (r ApiApiApplicationsAddLicensesPostRequest) AddLicensesCommand(addLicensesCommand AddLicensesCommand) ApiApiApplicationsAddLicensesPostRequest {
	r.addLicensesCommand = &addLicensesCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsAddLicensesPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsAddLicensesPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsAddLicensesPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsAddLicensesPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsAddLicensesPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsAddLicensesPostExecute(r)
}

/*
ApiApplicationsAddLicensesPost Submit a `add-licenses` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsAddLicensesPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsAddLicensesPost(ctx context.Context) ApiApiApplicationsAddLicensesPostRequest {
	return ApiApiApplicationsAddLicensesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsAddLicensesPostExecute(r ApiApiApplicationsAddLicensesPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsAddLicensesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/add-licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addLicensesCommand == nil {
		return localVarReturnValue, nil, reportError("addLicensesCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.addLicensesCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsAddMemberPostRequest struct {
	ctx              context.Context
	ApiService       *ApplicationsAPIService
	addMemberCommand *AddMemberCommand
	xRemsApiKey      *string
	xRemsUserId      *string
}

func (r ApiApiApplicationsAddMemberPostRequest) AddMemberCommand(addMemberCommand AddMemberCommand) ApiApiApplicationsAddMemberPostRequest {
	r.addMemberCommand = &addMemberCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsAddMemberPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsAddMemberPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsAddMemberPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsAddMemberPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsAddMemberPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsAddMemberPostExecute(r)
}

/*
ApiApplicationsAddMemberPost Submit a `add-member` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsAddMemberPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsAddMemberPost(ctx context.Context) ApiApiApplicationsAddMemberPostRequest {
	return ApiApiApplicationsAddMemberPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsAddMemberPostExecute(r ApiApiApplicationsAddMemberPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsAddMemberPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/add-member"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addMemberCommand == nil {
		return localVarReturnValue, nil, reportError("addMemberCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.addMemberCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsApplicationIdAttachmentsGetRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	applicationId int64
	xRemsApiKey   *string
	xRemsUserId   *string
	all           *bool
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsApplicationIdAttachmentsGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsApplicationIdAttachmentsGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsApplicationIdAttachmentsGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsApplicationIdAttachmentsGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

// Defaults to true. If set to false, the zip will only contain latest application attachments: no previous versions of attachments, and no event attachments.
func (r ApiApiApplicationsApplicationIdAttachmentsGetRequest) All(all bool) ApiApiApplicationsApplicationIdAttachmentsGetRequest {
	r.all = &all
	return r
}

func (r ApiApiApplicationsApplicationIdAttachmentsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiApplicationsApplicationIdAttachmentsGetExecute(r)
}

/*
ApiApplicationsApplicationIdAttachmentsGet Get attachments for an application as a zip file (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationId application id
	@return ApiApiApplicationsApplicationIdAttachmentsGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsApplicationIdAttachmentsGet(ctx context.Context, applicationId int64) ApiApiApplicationsApplicationIdAttachmentsGetRequest {
	return ApiApiApplicationsApplicationIdAttachmentsGetRequest{
		ApiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) ApiApplicationsApplicationIdAttachmentsGetExecute(r ApiApiApplicationsApplicationIdAttachmentsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsApplicationIdAttachmentsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{application-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"application-id"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.all != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "all", r.all, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiApplicationsApplicationIdGetRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	applicationId int64
	xRemsApiKey   *string
	xRemsUserId   *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsApplicationIdGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsApplicationIdGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsApplicationIdGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsApplicationIdGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsApplicationIdGetRequest) Execute() (*Application, *http.Response, error) {
	return r.ApiService.ApiApplicationsApplicationIdGetExecute(r)
}

/*
ApiApplicationsApplicationIdGet Get application by `application-id`. Application is customized for the requesting user (e.g. event visibility, permissions, etc). (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationId application id
	@return ApiApiApplicationsApplicationIdGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsApplicationIdGet(ctx context.Context, applicationId int64) ApiApiApplicationsApplicationIdGetRequest {
	return ApiApiApplicationsApplicationIdGetRequest{
		ApiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//
//	@return Application
func (a *ApplicationsAPIService) ApiApplicationsApplicationIdGetExecute(r ApiApiApplicationsApplicationIdGetRequest) (*Application, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsApplicationIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{application-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application-id"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGetRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	applicationId int64
	licenseId     int64
	language      string
	xRemsApiKey   *string
	xRemsUserId   *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGetExecute(r)
}

/*
ApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGet Get file associated with licence of type attachment associated with application. (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationId application id
	@param licenseId license id
	@param language language code
	@return ApiApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGet(ctx context.Context, applicationId int64, licenseId int64, language string) ApiApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGetRequest {
	return ApiApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGetRequest{
		ApiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		licenseId:     licenseId,
		language:      language,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) ApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGetExecute(r ApiApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsApplicationIdLicenseAttachmentLicenseIdLanguageGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{application-id}/license-attachment/{license-id}/{language}"
	localVarPath = strings.Replace(localVarPath, "{"+"application-id"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"license-id"+"}", url.PathEscape(parameterValueToString(r.licenseId, "licenseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"language"+"}", url.PathEscape(parameterValueToString(r.language, "language")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiApplicationsApplicationIdPdfGetRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	applicationId int64
	xRemsApiKey   *string
	xRemsUserId   *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsApplicationIdPdfGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsApplicationIdPdfGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsApplicationIdPdfGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsApplicationIdPdfGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsApplicationIdPdfGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiApplicationsApplicationIdPdfGetExecute(r)
}

/*
ApiApplicationsApplicationIdPdfGet Get a pdf version of an application (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationId application id
	@return ApiApiApplicationsApplicationIdPdfGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsApplicationIdPdfGet(ctx context.Context, applicationId int64) ApiApiApplicationsApplicationIdPdfGetRequest {
	return ApiApiApplicationsApplicationIdPdfGetRequest{
		ApiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) ApiApplicationsApplicationIdPdfGetExecute(r ApiApiApplicationsApplicationIdPdfGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsApplicationIdPdfGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{application-id}/pdf"
	localVarPath = strings.Replace(localVarPath, "{"+"application-id"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiApplicationsApplicationIdRawGetRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	applicationId int64
	xRemsApiKey   *string
	xRemsUserId   *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsApplicationIdRawGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsApplicationIdRawGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsApplicationIdRawGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsApplicationIdRawGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsApplicationIdRawGetRequest) Execute() (*ApplicationRaw, *http.Response, error) {
	return r.ApiService.ApiApplicationsApplicationIdRawGetExecute(r)
}

/*
ApiApplicationsApplicationIdRawGet Get application by `application-id`. Unlike the /api/applications/:application-id endpoint, the data here isn't customized for the requesting user (see schema for details). Suitable for integrations and exporting applications. (roles: owner, reporter)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationId application id
	@return ApiApiApplicationsApplicationIdRawGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsApplicationIdRawGet(ctx context.Context, applicationId int64) ApiApiApplicationsApplicationIdRawGetRequest {
	return ApiApiApplicationsApplicationIdRawGetRequest{
		ApiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//
//	@return ApplicationRaw
func (a *ApplicationsAPIService) ApiApplicationsApplicationIdRawGetExecute(r ApiApiApplicationsApplicationIdRawGetRequest) (*ApplicationRaw, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationRaw
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsApplicationIdRawGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{application-id}/raw"
	localVarPath = strings.Replace(localVarPath, "{"+"application-id"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsApprovePostRequest struct {
	ctx            context.Context
	ApiService     *ApplicationsAPIService
	approveCommand *ApproveCommand
	xRemsApiKey    *string
	xRemsUserId    *string
}

func (r ApiApiApplicationsApprovePostRequest) ApproveCommand(approveCommand ApproveCommand) ApiApiApplicationsApprovePostRequest {
	r.approveCommand = &approveCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsApprovePostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsApprovePostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsApprovePostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsApprovePostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsApprovePostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsApprovePostExecute(r)
}

/*
ApiApplicationsApprovePost Submit a `approve` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsApprovePostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsApprovePost(ctx context.Context) ApiApiApplicationsApprovePostRequest {
	return ApiApiApplicationsApprovePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsApprovePostExecute(r ApiApiApplicationsApprovePostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsApprovePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/approve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.approveCommand == nil {
		return localVarReturnValue, nil, reportError("approveCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.approveCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsAssignExternalIdPostRequest struct {
	ctx                     context.Context
	ApiService              *ApplicationsAPIService
	assignExternalIdCommand *AssignExternalIdCommand
	xRemsApiKey             *string
	xRemsUserId             *string
}

func (r ApiApiApplicationsAssignExternalIdPostRequest) AssignExternalIdCommand(assignExternalIdCommand AssignExternalIdCommand) ApiApiApplicationsAssignExternalIdPostRequest {
	r.assignExternalIdCommand = &assignExternalIdCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsAssignExternalIdPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsAssignExternalIdPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsAssignExternalIdPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsAssignExternalIdPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsAssignExternalIdPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsAssignExternalIdPostExecute(r)
}

/*
ApiApplicationsAssignExternalIdPost Submit a `assign-external-id` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsAssignExternalIdPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsAssignExternalIdPost(ctx context.Context) ApiApiApplicationsAssignExternalIdPostRequest {
	return ApiApiApplicationsAssignExternalIdPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsAssignExternalIdPostExecute(r ApiApiApplicationsAssignExternalIdPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsAssignExternalIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/assign-external-id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assignExternalIdCommand == nil {
		return localVarReturnValue, nil, reportError("assignExternalIdCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.assignExternalIdCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsAttachmentAttachmentIdGetRequest struct {
	ctx          context.Context
	ApiService   *ApplicationsAPIService
	attachmentId int64
	xRemsApiKey  *string
	xRemsUserId  *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsAttachmentAttachmentIdGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsAttachmentAttachmentIdGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsAttachmentAttachmentIdGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsAttachmentAttachmentIdGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsAttachmentAttachmentIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiApplicationsAttachmentAttachmentIdGetExecute(r)
}

/*
ApiApplicationsAttachmentAttachmentIdGet Get an attachment (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param attachmentId attachment id
	@return ApiApiApplicationsAttachmentAttachmentIdGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsAttachmentAttachmentIdGet(ctx context.Context, attachmentId int64) ApiApiApplicationsAttachmentAttachmentIdGetRequest {
	return ApiApiApplicationsAttachmentAttachmentIdGetRequest{
		ApiService:   a,
		ctx:          ctx,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) ApiApplicationsAttachmentAttachmentIdGetExecute(r ApiApiApplicationsAttachmentAttachmentIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsAttachmentAttachmentIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/attachment/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiApplicationsChangeApplicantPostRequest struct {
	ctx                    context.Context
	ApiService             *ApplicationsAPIService
	changeApplicantCommand *ChangeApplicantCommand
	xRemsApiKey            *string
	xRemsUserId            *string
}

func (r ApiApiApplicationsChangeApplicantPostRequest) ChangeApplicantCommand(changeApplicantCommand ChangeApplicantCommand) ApiApiApplicationsChangeApplicantPostRequest {
	r.changeApplicantCommand = &changeApplicantCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsChangeApplicantPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsChangeApplicantPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsChangeApplicantPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsChangeApplicantPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsChangeApplicantPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsChangeApplicantPostExecute(r)
}

/*
ApiApplicationsChangeApplicantPost Submit a `change-applicant` command for an application. Promote member of application to applicant. Previous applicant becomes a member. (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsChangeApplicantPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsChangeApplicantPost(ctx context.Context) ApiApiApplicationsChangeApplicantPostRequest {
	return ApiApiApplicationsChangeApplicantPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsChangeApplicantPostExecute(r ApiApiApplicationsChangeApplicantPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsChangeApplicantPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/change-applicant"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.changeApplicantCommand == nil {
		return localVarReturnValue, nil, reportError("changeApplicantCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.changeApplicantCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsChangeProcessingStatePostRequest struct {
	ctx                          context.Context
	ApiService                   *ApplicationsAPIService
	changeProcessingStateCommand *ChangeProcessingStateCommand
	xRemsApiKey                  *string
	xRemsUserId                  *string
}

func (r ApiApiApplicationsChangeProcessingStatePostRequest) ChangeProcessingStateCommand(changeProcessingStateCommand ChangeProcessingStateCommand) ApiApiApplicationsChangeProcessingStatePostRequest {
	r.changeProcessingStateCommand = &changeProcessingStateCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsChangeProcessingStatePostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsChangeProcessingStatePostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsChangeProcessingStatePostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsChangeProcessingStatePostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsChangeProcessingStatePostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsChangeProcessingStatePostExecute(r)
}

/*
ApiApplicationsChangeProcessingStatePost Submit a `change-processing-state` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsChangeProcessingStatePostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsChangeProcessingStatePost(ctx context.Context) ApiApiApplicationsChangeProcessingStatePostRequest {
	return ApiApiApplicationsChangeProcessingStatePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsChangeProcessingStatePostExecute(r ApiApiApplicationsChangeProcessingStatePostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsChangeProcessingStatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/change-processing-state"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.changeProcessingStateCommand == nil {
		return localVarReturnValue, nil, reportError("changeProcessingStateCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.changeProcessingStateCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsChangeResourcesPostRequest struct {
	ctx                    context.Context
	ApiService             *ApplicationsAPIService
	changeResourcesCommand *ChangeResourcesCommand
	xRemsApiKey            *string
	xRemsUserId            *string
}

func (r ApiApiApplicationsChangeResourcesPostRequest) ChangeResourcesCommand(changeResourcesCommand ChangeResourcesCommand) ApiApiApplicationsChangeResourcesPostRequest {
	r.changeResourcesCommand = &changeResourcesCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsChangeResourcesPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsChangeResourcesPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsChangeResourcesPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsChangeResourcesPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsChangeResourcesPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsChangeResourcesPostExecute(r)
}

/*
ApiApplicationsChangeResourcesPost Submit a `change-resources` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsChangeResourcesPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsChangeResourcesPost(ctx context.Context) ApiApiApplicationsChangeResourcesPostRequest {
	return ApiApiApplicationsChangeResourcesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsChangeResourcesPostExecute(r ApiApiApplicationsChangeResourcesPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsChangeResourcesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/change-resources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.changeResourcesCommand == nil {
		return localVarReturnValue, nil, reportError("changeResourcesCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.changeResourcesCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsClosePostRequest struct {
	ctx          context.Context
	ApiService   *ApplicationsAPIService
	closeCommand *CloseCommand
	xRemsApiKey  *string
	xRemsUserId  *string
}

func (r ApiApiApplicationsClosePostRequest) CloseCommand(closeCommand CloseCommand) ApiApiApplicationsClosePostRequest {
	r.closeCommand = &closeCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsClosePostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsClosePostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsClosePostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsClosePostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsClosePostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsClosePostExecute(r)
}

/*
ApiApplicationsClosePost Submit a `close` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsClosePostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsClosePost(ctx context.Context) ApiApiApplicationsClosePostRequest {
	return ApiApiApplicationsClosePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsClosePostExecute(r ApiApiApplicationsClosePostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsClosePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/close"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.closeCommand == nil {
		return localVarReturnValue, nil, reportError("closeCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.closeCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsCommandsGetRequest struct {
	ctx         context.Context
	ApiService  *ApplicationsAPIService
	xRemsApiKey *string
	xRemsUserId *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsCommandsGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsCommandsGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsCommandsGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsCommandsGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsCommandsGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.ApiApplicationsCommandsGetExecute(r)
}

/*
ApiApplicationsCommandsGet List of application commands (roles: handler, organization-owner, owner, reporter)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsCommandsGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsCommandsGet(ctx context.Context) ApiApiApplicationsCommandsGetRequest {
	return ApiApiApplicationsCommandsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []string
func (a *ApplicationsAPIService) ApiApplicationsCommandsGetExecute(r ApiApiApplicationsCommandsGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsCommandsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/commands"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsCopyAsNewPostRequest struct {
	ctx              context.Context
	ApiService       *ApplicationsAPIService
	copyAsNewCommand *CopyAsNewCommand
	xRemsApiKey      *string
	xRemsUserId      *string
}

func (r ApiApiApplicationsCopyAsNewPostRequest) CopyAsNewCommand(copyAsNewCommand CopyAsNewCommand) ApiApiApplicationsCopyAsNewPostRequest {
	r.copyAsNewCommand = &copyAsNewCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsCopyAsNewPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsCopyAsNewPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsCopyAsNewPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsCopyAsNewPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsCopyAsNewPostRequest) Execute() (*CopyAsNewResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsCopyAsNewPostExecute(r)
}

/*
ApiApplicationsCopyAsNewPost Create a new application as a copy of an existing application. (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsCopyAsNewPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsCopyAsNewPost(ctx context.Context) ApiApiApplicationsCopyAsNewPostRequest {
	return ApiApiApplicationsCopyAsNewPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CopyAsNewResponse
func (a *ApplicationsAPIService) ApiApplicationsCopyAsNewPostExecute(r ApiApiApplicationsCopyAsNewPostRequest) (*CopyAsNewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CopyAsNewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsCopyAsNewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/copy-as-new"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.copyAsNewCommand == nil {
		return localVarReturnValue, nil, reportError("copyAsNewCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.copyAsNewCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsCreatePostRequest struct {
	ctx                      context.Context
	ApiService               *ApplicationsAPIService
	createApplicationCommand *CreateApplicationCommand
	xRemsApiKey              *string
	xRemsUserId              *string
}

func (r ApiApiApplicationsCreatePostRequest) CreateApplicationCommand(createApplicationCommand CreateApplicationCommand) ApiApiApplicationsCreatePostRequest {
	r.createApplicationCommand = &createApplicationCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsCreatePostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsCreatePostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsCreatePostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsCreatePostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsCreatePostRequest) Execute() (*CreateApplicationResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsCreatePostExecute(r)
}

/*
ApiApplicationsCreatePost Create a new application (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsCreatePostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsCreatePost(ctx context.Context) ApiApiApplicationsCreatePostRequest {
	return ApiApiApplicationsCreatePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CreateApplicationResponse
func (a *ApplicationsAPIService) ApiApplicationsCreatePostExecute(r ApiApiApplicationsCreatePostRequest) (*CreateApplicationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateApplicationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsCreatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createApplicationCommand == nil {
		return localVarReturnValue, nil, reportError("createApplicationCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.createApplicationCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsDecidePostRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	decideCommand *DecideCommand
	xRemsApiKey   *string
	xRemsUserId   *string
}

func (r ApiApiApplicationsDecidePostRequest) DecideCommand(decideCommand DecideCommand) ApiApiApplicationsDecidePostRequest {
	r.decideCommand = &decideCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsDecidePostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsDecidePostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsDecidePostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsDecidePostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsDecidePostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsDecidePostExecute(r)
}

/*
ApiApplicationsDecidePost Submit a `decide` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsDecidePostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsDecidePost(ctx context.Context) ApiApiApplicationsDecidePostRequest {
	return ApiApiApplicationsDecidePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsDecidePostExecute(r ApiApiApplicationsDecidePostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsDecidePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/decide"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.decideCommand == nil {
		return localVarReturnValue, nil, reportError("decideCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.decideCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsDecidersGetRequest struct {
	ctx         context.Context
	ApiService  *ApplicationsAPIService
	xRemsApiKey *string
	xRemsUserId *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsDecidersGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsDecidersGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsDecidersGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsDecidersGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsDecidersGetRequest) Execute() ([]Decider, *http.Response, error) {
	return r.ApiService.ApiApplicationsDecidersGetExecute(r)
}

/*
ApiApplicationsDecidersGet Available deciders (roles: handler)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsDecidersGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsDecidersGet(ctx context.Context) ApiApiApplicationsDecidersGetRequest {
	return ApiApiApplicationsDecidersGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Decider
func (a *ApplicationsAPIService) ApiApplicationsDecidersGetExecute(r ApiApiApplicationsDecidersGetRequest) ([]Decider, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Decider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsDecidersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/deciders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsDeletePostRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	deleteCommand *DeleteCommand
	xRemsApiKey   *string
	xRemsUserId   *string
}

func (r ApiApiApplicationsDeletePostRequest) DeleteCommand(deleteCommand DeleteCommand) ApiApiApplicationsDeletePostRequest {
	r.deleteCommand = &deleteCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsDeletePostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsDeletePostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsDeletePostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsDeletePostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsDeletePostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsDeletePostExecute(r)
}

/*
ApiApplicationsDeletePost Submit a `delete` command for an application. Only drafts can be deleted. Only applicants can delete drafts. (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsDeletePostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsDeletePost(ctx context.Context) ApiApiApplicationsDeletePostRequest {
	return ApiApiApplicationsDeletePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsDeletePostExecute(r ApiApiApplicationsDeletePostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteCommand == nil {
		return localVarReturnValue, nil, reportError("deleteCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.deleteCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsExportGetRequest struct {
	ctx         context.Context
	ApiService  *ApplicationsAPIService
	formId      *int64
	xRemsApiKey *string
	xRemsUserId *string
}

// form id
func (r ApiApiApplicationsExportGetRequest) FormId(formId int64) ApiApiApplicationsExportGetRequest {
	r.formId = &formId
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsExportGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsExportGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsExportGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsExportGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsExportGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiApplicationsExportGetExecute(r)
}

/*
ApiApplicationsExportGet Export all submitted applications of a given form as CSV (roles: owner, reporter)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsExportGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsExportGet(ctx context.Context) ApiApiApplicationsExportGetRequest {
	return ApiApiApplicationsExportGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) ApiApplicationsExportGetExecute(r ApiApiApplicationsExportGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsExportGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.formId == nil {
		return nil, reportError("formId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "form-id", r.formId, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiApplicationsGetRequest struct {
	ctx         context.Context
	ApiService  *ApplicationsAPIService
	xRemsApiKey *string
	xRemsUserId *string
	query       *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

// search query [documentation](https://github.com/CSCfi/rems/blob/master/docs/search.md)
func (r ApiApiApplicationsGetRequest) Query(query string) ApiApiApplicationsGetRequest {
	r.query = &query
	return r
}

func (r ApiApiApplicationsGetRequest) Execute() ([]ApplicationOverview, *http.Response, error) {
	return r.ApiService.ApiApplicationsGetExecute(r)
}

/*
ApiApplicationsGet Get all applications which the current user can see (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsGet(ctx context.Context) ApiApiApplicationsGetRequest {
	return ApiApiApplicationsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ApplicationOverview
func (a *ApplicationsAPIService) ApiApplicationsGetExecute(r ApiApiApplicationsGetRequest) ([]ApplicationOverview, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ApplicationOverview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsHandledCountGetRequest struct {
	ctx         context.Context
	ApiService  *ApplicationsAPIService
	xRemsApiKey *string
	xRemsUserId *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsHandledCountGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsHandledCountGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsHandledCountGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsHandledCountGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsHandledCountGetRequest) Execute() (int64, *http.Response, error) {
	return r.ApiService.ApiApplicationsHandledCountGetExecute(r)
}

/*
ApiApplicationsHandledCountGet Get count of all applications that the current user no more needs to act on. (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsHandledCountGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsHandledCountGet(ctx context.Context) ApiApiApplicationsHandledCountGetRequest {
	return ApiApiApplicationsHandledCountGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return int64
func (a *ApplicationsAPIService) ApiApplicationsHandledCountGetExecute(r ApiApiApplicationsHandledCountGetRequest) (int64, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsHandledCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/handled/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsHandledGetRequest struct {
	ctx                context.Context
	ApiService         *ApplicationsAPIService
	xRemsApiKey        *string
	xRemsUserId        *string
	query              *string
	onlyActiveHandlers *bool
	limit              *int64
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsHandledGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsHandledGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsHandledGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsHandledGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

// search query [documentation](https://github.com/CSCfi/rems/blob/master/docs/search.md)
func (r ApiApiApplicationsHandledGetRequest) Query(query string) ApiApiApplicationsHandledGetRequest {
	r.query = &query
	return r
}

// return only workflow handlers that are active making a smaller result
func (r ApiApiApplicationsHandledGetRequest) OnlyActiveHandlers(onlyActiveHandlers bool) ApiApiApplicationsHandledGetRequest {
	r.onlyActiveHandlers = &onlyActiveHandlers
	return r
}

// how many results to return
func (r ApiApiApplicationsHandledGetRequest) Limit(limit int64) ApiApiApplicationsHandledGetRequest {
	r.limit = &limit
	return r
}

func (r ApiApiApplicationsHandledGetRequest) Execute() ([]ApplicationOverview, *http.Response, error) {
	return r.ApiService.ApiApplicationsHandledGetExecute(r)
}

/*
ApiApplicationsHandledGet Get all applications that the current user no more needs to act on. (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsHandledGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsHandledGet(ctx context.Context) ApiApiApplicationsHandledGetRequest {
	return ApiApiApplicationsHandledGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ApplicationOverview
func (a *ApplicationsAPIService) ApiApplicationsHandledGetExecute(r ApiApiApplicationsHandledGetRequest) ([]ApplicationOverview, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ApplicationOverview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsHandledGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/handled"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	if r.onlyActiveHandlers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only-active-handlers", r.onlyActiveHandlers, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsInviteDeciderPostRequest struct {
	ctx                  context.Context
	ApiService           *ApplicationsAPIService
	inviteDeciderCommand *InviteDeciderCommand
	xRemsApiKey          *string
	xRemsUserId          *string
}

func (r ApiApiApplicationsInviteDeciderPostRequest) InviteDeciderCommand(inviteDeciderCommand InviteDeciderCommand) ApiApiApplicationsInviteDeciderPostRequest {
	r.inviteDeciderCommand = &inviteDeciderCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsInviteDeciderPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsInviteDeciderPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsInviteDeciderPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsInviteDeciderPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsInviteDeciderPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsInviteDeciderPostExecute(r)
}

/*
ApiApplicationsInviteDeciderPost Submit a `invite-decider` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsInviteDeciderPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsInviteDeciderPost(ctx context.Context) ApiApiApplicationsInviteDeciderPostRequest {
	return ApiApiApplicationsInviteDeciderPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsInviteDeciderPostExecute(r ApiApiApplicationsInviteDeciderPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsInviteDeciderPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/invite-decider"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inviteDeciderCommand == nil {
		return localVarReturnValue, nil, reportError("inviteDeciderCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.inviteDeciderCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsInviteMemberPostRequest struct {
	ctx                 context.Context
	ApiService          *ApplicationsAPIService
	inviteMemberCommand *InviteMemberCommand
	xRemsApiKey         *string
	xRemsUserId         *string
}

func (r ApiApiApplicationsInviteMemberPostRequest) InviteMemberCommand(inviteMemberCommand InviteMemberCommand) ApiApiApplicationsInviteMemberPostRequest {
	r.inviteMemberCommand = &inviteMemberCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsInviteMemberPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsInviteMemberPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsInviteMemberPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsInviteMemberPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsInviteMemberPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsInviteMemberPostExecute(r)
}

/*
ApiApplicationsInviteMemberPost Submit a `invite-member` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsInviteMemberPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsInviteMemberPost(ctx context.Context) ApiApiApplicationsInviteMemberPostRequest {
	return ApiApiApplicationsInviteMemberPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsInviteMemberPostExecute(r ApiApiApplicationsInviteMemberPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsInviteMemberPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/invite-member"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inviteMemberCommand == nil {
		return localVarReturnValue, nil, reportError("inviteMemberCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.inviteMemberCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsInviteReviewerPostRequest struct {
	ctx                   context.Context
	ApiService            *ApplicationsAPIService
	inviteReviewerCommand *InviteReviewerCommand
	xRemsApiKey           *string
	xRemsUserId           *string
}

func (r ApiApiApplicationsInviteReviewerPostRequest) InviteReviewerCommand(inviteReviewerCommand InviteReviewerCommand) ApiApiApplicationsInviteReviewerPostRequest {
	r.inviteReviewerCommand = &inviteReviewerCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsInviteReviewerPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsInviteReviewerPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsInviteReviewerPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsInviteReviewerPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsInviteReviewerPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsInviteReviewerPostExecute(r)
}

/*
ApiApplicationsInviteReviewerPost Submit a `invite-reviewer` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsInviteReviewerPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsInviteReviewerPost(ctx context.Context) ApiApiApplicationsInviteReviewerPostRequest {
	return ApiApiApplicationsInviteReviewerPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsInviteReviewerPostExecute(r ApiApiApplicationsInviteReviewerPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsInviteReviewerPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/invite-reviewer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inviteReviewerCommand == nil {
		return localVarReturnValue, nil, reportError("inviteReviewerCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.inviteReviewerCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsMembersGetRequest struct {
	ctx         context.Context
	ApiService  *ApplicationsAPIService
	xRemsApiKey *string
	xRemsUserId *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsMembersGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsMembersGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsMembersGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsMembersGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsMembersGetRequest) Execute() ([]Applicant, *http.Response, error) {
	return r.ApiService.ApiApplicationsMembersGetExecute(r)
}

/*
ApiApplicationsMembersGet Existing REMS users available for application membership (roles: handler)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsMembersGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsMembersGet(ctx context.Context) ApiApiApplicationsMembersGetRequest {
	return ApiApiApplicationsMembersGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Applicant
func (a *ApplicationsAPIService) ApiApplicationsMembersGetExecute(r ApiApiApplicationsMembersGetRequest) ([]Applicant, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Applicant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsMembersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/members"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsRedactAttachmentsPostRequest struct {
	ctx                      context.Context
	ApiService               *ApplicationsAPIService
	redactAttachmentsCommand *RedactAttachmentsCommand
	xRemsApiKey              *string
	xRemsUserId              *string
}

func (r ApiApiApplicationsRedactAttachmentsPostRequest) RedactAttachmentsCommand(redactAttachmentsCommand RedactAttachmentsCommand) ApiApiApplicationsRedactAttachmentsPostRequest {
	r.redactAttachmentsCommand = &redactAttachmentsCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsRedactAttachmentsPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsRedactAttachmentsPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsRedactAttachmentsPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsRedactAttachmentsPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsRedactAttachmentsPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsRedactAttachmentsPostExecute(r)
}

/*
ApiApplicationsRedactAttachmentsPost Submit a `redact-attachments` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsRedactAttachmentsPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsRedactAttachmentsPost(ctx context.Context) ApiApiApplicationsRedactAttachmentsPostRequest {
	return ApiApiApplicationsRedactAttachmentsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsRedactAttachmentsPostExecute(r ApiApiApplicationsRedactAttachmentsPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsRedactAttachmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/redact-attachments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.redactAttachmentsCommand == nil {
		return localVarReturnValue, nil, reportError("redactAttachmentsCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.redactAttachmentsCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsRejectPostRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	rejectCommand *RejectCommand
	xRemsApiKey   *string
	xRemsUserId   *string
}

func (r ApiApiApplicationsRejectPostRequest) RejectCommand(rejectCommand RejectCommand) ApiApiApplicationsRejectPostRequest {
	r.rejectCommand = &rejectCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsRejectPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsRejectPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsRejectPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsRejectPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsRejectPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsRejectPostExecute(r)
}

/*
ApiApplicationsRejectPost Submit a `reject` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsRejectPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsRejectPost(ctx context.Context) ApiApiApplicationsRejectPostRequest {
	return ApiApiApplicationsRejectPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsRejectPostExecute(r ApiApiApplicationsRejectPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsRejectPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/reject"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rejectCommand == nil {
		return localVarReturnValue, nil, reportError("rejectCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.rejectCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsRemarkPostRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	remarkCommand *RemarkCommand
	xRemsApiKey   *string
	xRemsUserId   *string
}

func (r ApiApiApplicationsRemarkPostRequest) RemarkCommand(remarkCommand RemarkCommand) ApiApiApplicationsRemarkPostRequest {
	r.remarkCommand = &remarkCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsRemarkPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsRemarkPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsRemarkPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsRemarkPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsRemarkPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsRemarkPostExecute(r)
}

/*
ApiApplicationsRemarkPost Submit a `remark` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsRemarkPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsRemarkPost(ctx context.Context) ApiApiApplicationsRemarkPostRequest {
	return ApiApiApplicationsRemarkPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsRemarkPostExecute(r ApiApiApplicationsRemarkPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsRemarkPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/remark"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.remarkCommand == nil {
		return localVarReturnValue, nil, reportError("remarkCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.remarkCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsRemoveMemberPostRequest struct {
	ctx                 context.Context
	ApiService          *ApplicationsAPIService
	removeMemberCommand *RemoveMemberCommand
	xRemsApiKey         *string
	xRemsUserId         *string
}

func (r ApiApiApplicationsRemoveMemberPostRequest) RemoveMemberCommand(removeMemberCommand RemoveMemberCommand) ApiApiApplicationsRemoveMemberPostRequest {
	r.removeMemberCommand = &removeMemberCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsRemoveMemberPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsRemoveMemberPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsRemoveMemberPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsRemoveMemberPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsRemoveMemberPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsRemoveMemberPostExecute(r)
}

/*
ApiApplicationsRemoveMemberPost Submit a `remove-member` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsRemoveMemberPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsRemoveMemberPost(ctx context.Context) ApiApiApplicationsRemoveMemberPostRequest {
	return ApiApiApplicationsRemoveMemberPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsRemoveMemberPostExecute(r ApiApiApplicationsRemoveMemberPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsRemoveMemberPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/remove-member"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.removeMemberCommand == nil {
		return localVarReturnValue, nil, reportError("removeMemberCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.removeMemberCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsRequestDecisionPostRequest struct {
	ctx                    context.Context
	ApiService             *ApplicationsAPIService
	requestDecisionCommand *RequestDecisionCommand
	xRemsApiKey            *string
	xRemsUserId            *string
}

func (r ApiApiApplicationsRequestDecisionPostRequest) RequestDecisionCommand(requestDecisionCommand RequestDecisionCommand) ApiApiApplicationsRequestDecisionPostRequest {
	r.requestDecisionCommand = &requestDecisionCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsRequestDecisionPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsRequestDecisionPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsRequestDecisionPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsRequestDecisionPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsRequestDecisionPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsRequestDecisionPostExecute(r)
}

/*
ApiApplicationsRequestDecisionPost Submit a `request-decision` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsRequestDecisionPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsRequestDecisionPost(ctx context.Context) ApiApiApplicationsRequestDecisionPostRequest {
	return ApiApiApplicationsRequestDecisionPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsRequestDecisionPostExecute(r ApiApiApplicationsRequestDecisionPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsRequestDecisionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/request-decision"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestDecisionCommand == nil {
		return localVarReturnValue, nil, reportError("requestDecisionCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.requestDecisionCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsRequestReviewPostRequest struct {
	ctx                  context.Context
	ApiService           *ApplicationsAPIService
	requestReviewCommand *RequestReviewCommand
	xRemsApiKey          *string
	xRemsUserId          *string
}

func (r ApiApiApplicationsRequestReviewPostRequest) RequestReviewCommand(requestReviewCommand RequestReviewCommand) ApiApiApplicationsRequestReviewPostRequest {
	r.requestReviewCommand = &requestReviewCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsRequestReviewPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsRequestReviewPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsRequestReviewPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsRequestReviewPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsRequestReviewPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsRequestReviewPostExecute(r)
}

/*
ApiApplicationsRequestReviewPost Submit a `request-review` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsRequestReviewPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsRequestReviewPost(ctx context.Context) ApiApiApplicationsRequestReviewPostRequest {
	return ApiApiApplicationsRequestReviewPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsRequestReviewPostExecute(r ApiApiApplicationsRequestReviewPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsRequestReviewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/request-review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestReviewCommand == nil {
		return localVarReturnValue, nil, reportError("requestReviewCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.requestReviewCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsReturnPostRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	returnCommand *ReturnCommand
	xRemsApiKey   *string
	xRemsUserId   *string
}

func (r ApiApiApplicationsReturnPostRequest) ReturnCommand(returnCommand ReturnCommand) ApiApiApplicationsReturnPostRequest {
	r.returnCommand = &returnCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsReturnPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsReturnPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsReturnPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsReturnPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsReturnPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsReturnPostExecute(r)
}

/*
ApiApplicationsReturnPost Submit a `return` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsReturnPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsReturnPost(ctx context.Context) ApiApiApplicationsReturnPostRequest {
	return ApiApiApplicationsReturnPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsReturnPostExecute(r ApiApiApplicationsReturnPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsReturnPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/return"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnCommand == nil {
		return localVarReturnValue, nil, reportError("returnCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.returnCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsReviewPostRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	reviewCommand *ReviewCommand
	xRemsApiKey   *string
	xRemsUserId   *string
}

func (r ApiApiApplicationsReviewPostRequest) ReviewCommand(reviewCommand ReviewCommand) ApiApiApplicationsReviewPostRequest {
	r.reviewCommand = &reviewCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsReviewPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsReviewPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsReviewPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsReviewPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsReviewPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsReviewPostExecute(r)
}

/*
ApiApplicationsReviewPost Submit a `review` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsReviewPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsReviewPost(ctx context.Context) ApiApiApplicationsReviewPostRequest {
	return ApiApiApplicationsReviewPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsReviewPostExecute(r ApiApiApplicationsReviewPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsReviewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reviewCommand == nil {
		return localVarReturnValue, nil, reportError("reviewCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.reviewCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsReviewersGetRequest struct {
	ctx         context.Context
	ApiService  *ApplicationsAPIService
	xRemsApiKey *string
	xRemsUserId *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsReviewersGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsReviewersGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsReviewersGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsReviewersGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsReviewersGetRequest) Execute() ([]Reviewer, *http.Response, error) {
	return r.ApiService.ApiApplicationsReviewersGetExecute(r)
}

/*
ApiApplicationsReviewersGet Available reviewers (roles: handler)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsReviewersGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsReviewersGet(ctx context.Context) ApiApiApplicationsReviewersGetRequest {
	return ApiApiApplicationsReviewersGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Reviewer
func (a *ApplicationsAPIService) ApiApplicationsReviewersGetExecute(r ApiApiApplicationsReviewersGetRequest) ([]Reviewer, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Reviewer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsReviewersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/reviewers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsRevokePostRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	revokeCommand *RevokeCommand
	xRemsApiKey   *string
	xRemsUserId   *string
}

func (r ApiApiApplicationsRevokePostRequest) RevokeCommand(revokeCommand RevokeCommand) ApiApiApplicationsRevokePostRequest {
	r.revokeCommand = &revokeCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsRevokePostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsRevokePostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsRevokePostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsRevokePostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsRevokePostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsRevokePostExecute(r)
}

/*
ApiApplicationsRevokePost Submit a `revoke` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsRevokePostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsRevokePost(ctx context.Context) ApiApiApplicationsRevokePostRequest {
	return ApiApiApplicationsRevokePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsRevokePostExecute(r ApiApiApplicationsRevokePostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsRevokePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/revoke"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revokeCommand == nil {
		return localVarReturnValue, nil, reportError("revokeCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.revokeCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsSaveDraftPostRequest struct {
	ctx              context.Context
	ApiService       *ApplicationsAPIService
	saveDraftCommand *SaveDraftCommand
	xRemsApiKey      *string
	xRemsUserId      *string
}

func (r ApiApiApplicationsSaveDraftPostRequest) SaveDraftCommand(saveDraftCommand SaveDraftCommand) ApiApiApplicationsSaveDraftPostRequest {
	r.saveDraftCommand = &saveDraftCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsSaveDraftPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsSaveDraftPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsSaveDraftPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsSaveDraftPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsSaveDraftPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsSaveDraftPostExecute(r)
}

/*
ApiApplicationsSaveDraftPost Submit a `save-draft` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsSaveDraftPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsSaveDraftPost(ctx context.Context) ApiApiApplicationsSaveDraftPostRequest {
	return ApiApiApplicationsSaveDraftPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsSaveDraftPostExecute(r ApiApiApplicationsSaveDraftPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsSaveDraftPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/save-draft"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.saveDraftCommand == nil {
		return localVarReturnValue, nil, reportError("saveDraftCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.saveDraftCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsSubmitPostRequest struct {
	ctx           context.Context
	ApiService    *ApplicationsAPIService
	submitCommand *SubmitCommand
	xRemsApiKey   *string
	xRemsUserId   *string
}

func (r ApiApiApplicationsSubmitPostRequest) SubmitCommand(submitCommand SubmitCommand) ApiApiApplicationsSubmitPostRequest {
	r.submitCommand = &submitCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsSubmitPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsSubmitPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsSubmitPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsSubmitPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsSubmitPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsSubmitPostExecute(r)
}

/*
ApiApplicationsSubmitPost Submit a `submit` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsSubmitPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsSubmitPost(ctx context.Context) ApiApiApplicationsSubmitPostRequest {
	return ApiApiApplicationsSubmitPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsSubmitPostExecute(r ApiApiApplicationsSubmitPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsSubmitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/submit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitCommand == nil {
		return localVarReturnValue, nil, reportError("submitCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.submitCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsTodoGetRequest struct {
	ctx         context.Context
	ApiService  *ApplicationsAPIService
	xRemsApiKey *string
	xRemsUserId *string
	query       *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsTodoGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsTodoGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsTodoGetRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsTodoGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

// search query [documentation](https://github.com/CSCfi/rems/blob/master/docs/search.md)
func (r ApiApiApplicationsTodoGetRequest) Query(query string) ApiApiApplicationsTodoGetRequest {
	r.query = &query
	return r
}

func (r ApiApiApplicationsTodoGetRequest) Execute() ([]ApplicationOverview, *http.Response, error) {
	return r.ApiService.ApiApplicationsTodoGetExecute(r)
}

/*
ApiApplicationsTodoGet Get all applications that the current user needs to act on. (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsTodoGetRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsTodoGet(ctx context.Context) ApiApiApplicationsTodoGetRequest {
	return ApiApiApplicationsTodoGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ApplicationOverview
func (a *ApplicationsAPIService) ApiApplicationsTodoGetExecute(r ApiApiApplicationsTodoGetRequest) ([]ApplicationOverview, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ApplicationOverview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsTodoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/todo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsUninviteMemberPostRequest struct {
	ctx                   context.Context
	ApiService            *ApplicationsAPIService
	uninviteMemberCommand *UninviteMemberCommand
	xRemsApiKey           *string
	xRemsUserId           *string
}

func (r ApiApiApplicationsUninviteMemberPostRequest) UninviteMemberCommand(uninviteMemberCommand UninviteMemberCommand) ApiApiApplicationsUninviteMemberPostRequest {
	r.uninviteMemberCommand = &uninviteMemberCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsUninviteMemberPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsUninviteMemberPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsUninviteMemberPostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsUninviteMemberPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsUninviteMemberPostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsUninviteMemberPostExecute(r)
}

/*
ApiApplicationsUninviteMemberPost Submit a `uninvite-member` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsUninviteMemberPostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsUninviteMemberPost(ctx context.Context) ApiApiApplicationsUninviteMemberPostRequest {
	return ApiApiApplicationsUninviteMemberPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsUninviteMemberPostExecute(r ApiApiApplicationsUninviteMemberPostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsUninviteMemberPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/uninvite-member"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uninviteMemberCommand == nil {
		return localVarReturnValue, nil, reportError("uninviteMemberCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.uninviteMemberCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsValidatePostRequest struct {
	ctx             context.Context
	ApiService      *ApplicationsAPIService
	validateRequest *ValidateRequest
	xRemsApiKey     *string
	xRemsUserId     *string
}

func (r ApiApiApplicationsValidatePostRequest) ValidateRequest(validateRequest ValidateRequest) ApiApiApplicationsValidatePostRequest {
	r.validateRequest = &validateRequest
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsValidatePostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsValidatePostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsValidatePostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsValidatePostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsValidatePostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsValidatePostExecute(r)
}

/*
ApiApplicationsValidatePost Validate the form, like in save, but nothing is saved. NB: At the moment, both errors and validations are identical, but this may not always be so. (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsValidatePostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsValidatePost(ctx context.Context) ApiApiApplicationsValidatePostRequest {
	return ApiApiApplicationsValidatePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsValidatePostExecute(r ApiApiApplicationsValidatePostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsValidatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.validateRequest == nil {
		return localVarReturnValue, nil, reportError("validateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.validateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiApplicationsVotePostRequest struct {
	ctx         context.Context
	ApiService  *ApplicationsAPIService
	voteCommand *VoteCommand
	xRemsApiKey *string
	xRemsUserId *string
}

func (r ApiApiApplicationsVotePostRequest) VoteCommand(voteCommand VoteCommand) ApiApiApplicationsVotePostRequest {
	r.voteCommand = &voteCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiApplicationsVotePostRequest) XRemsApiKey(xRemsApiKey string) ApiApiApplicationsVotePostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiApplicationsVotePostRequest) XRemsUserId(xRemsUserId string) ApiApiApplicationsVotePostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiApplicationsVotePostRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiApplicationsVotePostExecute(r)
}

/*
ApiApplicationsVotePost Submit a `vote` command for an application.  (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiApplicationsVotePostRequest
*/
func (a *ApplicationsAPIService) ApiApplicationsVotePost(ctx context.Context) ApiApiApplicationsVotePostRequest {
	return ApiApiApplicationsVotePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *ApplicationsAPIService) ApiApplicationsVotePostExecute(r ApiApiApplicationsVotePostRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiApplicationsVotePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/vote"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.voteCommand == nil {
		return localVarReturnValue, nil, reportError("voteCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.voteCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiMyApplicationsGetRequest struct {
	ctx         context.Context
	ApiService  *ApplicationsAPIService
	xRemsApiKey *string
	xRemsUserId *string
	query       *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiMyApplicationsGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiMyApplicationsGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiMyApplicationsGetRequest) XRemsUserId(xRemsUserId string) ApiApiMyApplicationsGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

// search query [documentation](https://github.com/CSCfi/rems/blob/master/docs/search.md)
func (r ApiApiMyApplicationsGetRequest) Query(query string) ApiApiMyApplicationsGetRequest {
	r.query = &query
	return r
}

func (r ApiApiMyApplicationsGetRequest) Execute() ([]ApplicationOverview, *http.Response, error) {
	return r.ApiService.ApiMyApplicationsGetExecute(r)
}

/*
ApiMyApplicationsGet Get the current user's own applications (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiMyApplicationsGetRequest
*/
func (a *ApplicationsAPIService) ApiMyApplicationsGet(ctx context.Context) ApiApiMyApplicationsGetRequest {
	return ApiApiMyApplicationsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ApplicationOverview
func (a *ApplicationsAPIService) ApiMyApplicationsGetExecute(r ApiApiMyApplicationsGetRequest) ([]ApplicationOverview, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ApplicationOverview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ApiMyApplicationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/my-applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
