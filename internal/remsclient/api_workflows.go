/*
REMS API

REMS API Services

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package remsclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// WorkflowsAPIService WorkflowsAPI service
type WorkflowsAPIService service

type ApiApiWorkflowsActorsGetRequest struct {
	ctx         context.Context
	ApiService  *WorkflowsAPIService
	xRemsApiKey *string
	xRemsUserId *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiWorkflowsActorsGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiWorkflowsActorsGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiWorkflowsActorsGetRequest) XRemsUserId(xRemsUserId string) ApiApiWorkflowsActorsGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiWorkflowsActorsGetRequest) Execute() ([]AvailableActor, *http.Response, error) {
	return r.ApiService.ApiWorkflowsActorsGetExecute(r)
}

/*
ApiWorkflowsActorsGet List of available actors (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiWorkflowsActorsGetRequest
*/
func (a *WorkflowsAPIService) ApiWorkflowsActorsGet(ctx context.Context) ApiApiWorkflowsActorsGetRequest {
	return ApiApiWorkflowsActorsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []AvailableActor
func (a *WorkflowsAPIService) ApiWorkflowsActorsGetExecute(r ApiApiWorkflowsActorsGetRequest) ([]AvailableActor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AvailableActor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowsAPIService.ApiWorkflowsActorsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/workflows/actors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiWorkflowsArchivedPutRequest struct {
	ctx             context.Context
	ApiService      *WorkflowsAPIService
	archivedCommand *ArchivedCommand
	xRemsApiKey     *string
	xRemsUserId     *string
}

func (r ApiApiWorkflowsArchivedPutRequest) ArchivedCommand(archivedCommand ArchivedCommand) ApiApiWorkflowsArchivedPutRequest {
	r.archivedCommand = &archivedCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiWorkflowsArchivedPutRequest) XRemsApiKey(xRemsApiKey string) ApiApiWorkflowsArchivedPutRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiWorkflowsArchivedPutRequest) XRemsUserId(xRemsUserId string) ApiApiWorkflowsArchivedPutRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiWorkflowsArchivedPutRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiWorkflowsArchivedPutExecute(r)
}

/*
ApiWorkflowsArchivedPut Archive or unarchive workflow (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiWorkflowsArchivedPutRequest
*/
func (a *WorkflowsAPIService) ApiWorkflowsArchivedPut(ctx context.Context) ApiApiWorkflowsArchivedPutRequest {
	return ApiApiWorkflowsArchivedPutRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *WorkflowsAPIService) ApiWorkflowsArchivedPutExecute(r ApiApiWorkflowsArchivedPutRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowsAPIService.ApiWorkflowsArchivedPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/workflows/archived"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.archivedCommand == nil {
		return localVarReturnValue, nil, reportError("archivedCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.archivedCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiWorkflowsCreatePostRequest struct {
	ctx                   context.Context
	ApiService            *WorkflowsAPIService
	createWorkflowCommand *CreateWorkflowCommand
	xRemsApiKey           *string
	xRemsUserId           *string
}

func (r ApiApiWorkflowsCreatePostRequest) CreateWorkflowCommand(createWorkflowCommand CreateWorkflowCommand) ApiApiWorkflowsCreatePostRequest {
	r.createWorkflowCommand = &createWorkflowCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiWorkflowsCreatePostRequest) XRemsApiKey(xRemsApiKey string) ApiApiWorkflowsCreatePostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiWorkflowsCreatePostRequest) XRemsUserId(xRemsUserId string) ApiApiWorkflowsCreatePostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiWorkflowsCreatePostRequest) Execute() (*CreateWorkflowResponse, *http.Response, error) {
	return r.ApiService.ApiWorkflowsCreatePostExecute(r)
}

/*
ApiWorkflowsCreatePost Create workflow (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiWorkflowsCreatePostRequest
*/
func (a *WorkflowsAPIService) ApiWorkflowsCreatePost(ctx context.Context) ApiApiWorkflowsCreatePostRequest {
	return ApiApiWorkflowsCreatePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CreateWorkflowResponse
func (a *WorkflowsAPIService) ApiWorkflowsCreatePostExecute(r ApiApiWorkflowsCreatePostRequest) (*CreateWorkflowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateWorkflowResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowsAPIService.ApiWorkflowsCreatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/workflows/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createWorkflowCommand == nil {
		return localVarReturnValue, nil, reportError("createWorkflowCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.createWorkflowCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiWorkflowsEditPutRequest struct {
	ctx                 context.Context
	ApiService          *WorkflowsAPIService
	editWorkflowCommand *EditWorkflowCommand
	xRemsApiKey         *string
	xRemsUserId         *string
}

func (r ApiApiWorkflowsEditPutRequest) EditWorkflowCommand(editWorkflowCommand EditWorkflowCommand) ApiApiWorkflowsEditPutRequest {
	r.editWorkflowCommand = &editWorkflowCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiWorkflowsEditPutRequest) XRemsApiKey(xRemsApiKey string) ApiApiWorkflowsEditPutRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiWorkflowsEditPutRequest) XRemsUserId(xRemsUserId string) ApiApiWorkflowsEditPutRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiWorkflowsEditPutRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiWorkflowsEditPutExecute(r)
}

/*
ApiWorkflowsEditPut Edit workflow title and handlers (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiWorkflowsEditPutRequest
*/
func (a *WorkflowsAPIService) ApiWorkflowsEditPut(ctx context.Context) ApiApiWorkflowsEditPutRequest {
	return ApiApiWorkflowsEditPutRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *WorkflowsAPIService) ApiWorkflowsEditPutExecute(r ApiApiWorkflowsEditPutRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowsAPIService.ApiWorkflowsEditPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/workflows/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.editWorkflowCommand == nil {
		return localVarReturnValue, nil, reportError("editWorkflowCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.editWorkflowCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiWorkflowsEnabledPutRequest struct {
	ctx            context.Context
	ApiService     *WorkflowsAPIService
	enabledCommand *EnabledCommand
	xRemsApiKey    *string
	xRemsUserId    *string
}

func (r ApiApiWorkflowsEnabledPutRequest) EnabledCommand(enabledCommand EnabledCommand) ApiApiWorkflowsEnabledPutRequest {
	r.enabledCommand = &enabledCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiWorkflowsEnabledPutRequest) XRemsApiKey(xRemsApiKey string) ApiApiWorkflowsEnabledPutRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiWorkflowsEnabledPutRequest) XRemsUserId(xRemsUserId string) ApiApiWorkflowsEnabledPutRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiWorkflowsEnabledPutRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiWorkflowsEnabledPutExecute(r)
}

/*
ApiWorkflowsEnabledPut Enable or disable workflow (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiWorkflowsEnabledPutRequest
*/
func (a *WorkflowsAPIService) ApiWorkflowsEnabledPut(ctx context.Context) ApiApiWorkflowsEnabledPutRequest {
	return ApiApiWorkflowsEnabledPutRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *WorkflowsAPIService) ApiWorkflowsEnabledPutExecute(r ApiApiWorkflowsEnabledPutRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowsAPIService.ApiWorkflowsEnabledPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/workflows/enabled"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enabledCommand == nil {
		return localVarReturnValue, nil, reportError("enabledCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.enabledCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiWorkflowsGetRequest struct {
	ctx         context.Context
	ApiService  *WorkflowsAPIService
	xRemsApiKey *string
	xRemsUserId *string
	disabled    *bool
	archived    *bool
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiWorkflowsGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiWorkflowsGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiWorkflowsGetRequest) XRemsUserId(xRemsUserId string) ApiApiWorkflowsGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

// whether to include disabled workflows
func (r ApiApiWorkflowsGetRequest) Disabled(disabled bool) ApiApiWorkflowsGetRequest {
	r.disabled = &disabled
	return r
}

// whether to include archived workflows
func (r ApiApiWorkflowsGetRequest) Archived(archived bool) ApiApiWorkflowsGetRequest {
	r.archived = &archived
	return r
}

func (r ApiApiWorkflowsGetRequest) Execute() ([]Workflow, *http.Response, error) {
	return r.ApiService.ApiWorkflowsGetExecute(r)
}

/*
ApiWorkflowsGet Get workflows (roles: handler, organization-owner, owner, reporter)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiWorkflowsGetRequest
*/
func (a *WorkflowsAPIService) ApiWorkflowsGet(ctx context.Context) ApiApiWorkflowsGetRequest {
	return ApiApiWorkflowsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Workflow
func (a *WorkflowsAPIService) ApiWorkflowsGetExecute(r ApiApiWorkflowsGetRequest) ([]Workflow, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowsAPIService.ApiWorkflowsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/workflows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.disabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disabled", r.disabled, "", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiWorkflowsWorkflowIdGetRequest struct {
	ctx         context.Context
	ApiService  *WorkflowsAPIService
	workflowId  int64
	xRemsApiKey *string
	xRemsUserId *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiWorkflowsWorkflowIdGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiWorkflowsWorkflowIdGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiWorkflowsWorkflowIdGetRequest) XRemsUserId(xRemsUserId string) ApiApiWorkflowsWorkflowIdGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiWorkflowsWorkflowIdGetRequest) Execute() (*Workflow, *http.Response, error) {
	return r.ApiService.ApiWorkflowsWorkflowIdGetExecute(r)
}

/*
ApiWorkflowsWorkflowIdGet Get workflow by id (roles: handler, organization-owner, owner, reporter)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId workflow-id
	@return ApiApiWorkflowsWorkflowIdGetRequest
*/
func (a *WorkflowsAPIService) ApiWorkflowsWorkflowIdGet(ctx context.Context, workflowId int64) ApiApiWorkflowsWorkflowIdGetRequest {
	return ApiApiWorkflowsWorkflowIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
//
//	@return Workflow
func (a *WorkflowsAPIService) ApiWorkflowsWorkflowIdGetExecute(r ApiApiWorkflowsWorkflowIdGetRequest) (*Workflow, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowsAPIService.ApiWorkflowsWorkflowIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/workflows/{workflow-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow-id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
