/*
REMS API

REMS API Services

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package remsclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// CatalogueItemsAPIService CatalogueItemsAPI service
type CatalogueItemsAPIService service

type ApiApiCatalogueItemsArchivedPutRequest struct {
	ctx             context.Context
	ApiService      *CatalogueItemsAPIService
	archivedCommand *ArchivedCommand
	xRemsApiKey     *string
	xRemsUserId     *string
}

func (r ApiApiCatalogueItemsArchivedPutRequest) ArchivedCommand(archivedCommand ArchivedCommand) ApiApiCatalogueItemsArchivedPutRequest {
	r.archivedCommand = &archivedCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiCatalogueItemsArchivedPutRequest) XRemsApiKey(xRemsApiKey string) ApiApiCatalogueItemsArchivedPutRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiCatalogueItemsArchivedPutRequest) XRemsUserId(xRemsUserId string) ApiApiCatalogueItemsArchivedPutRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiCatalogueItemsArchivedPutRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiCatalogueItemsArchivedPutExecute(r)
}

/*
ApiCatalogueItemsArchivedPut Archive or unarchive catalogue item (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiCatalogueItemsArchivedPutRequest
*/
func (a *CatalogueItemsAPIService) ApiCatalogueItemsArchivedPut(ctx context.Context) ApiApiCatalogueItemsArchivedPutRequest {
	return ApiApiCatalogueItemsArchivedPutRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *CatalogueItemsAPIService) ApiCatalogueItemsArchivedPutExecute(r ApiApiCatalogueItemsArchivedPutRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogueItemsAPIService.ApiCatalogueItemsArchivedPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalogue-items/archived"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.archivedCommand == nil {
		return localVarReturnValue, nil, reportError("archivedCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.archivedCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiCatalogueItemsCreatePostRequest struct {
	ctx                        context.Context
	ApiService                 *CatalogueItemsAPIService
	createCatalogueItemCommand *CreateCatalogueItemCommand
	xRemsApiKey                *string
	xRemsUserId                *string
}

func (r ApiApiCatalogueItemsCreatePostRequest) CreateCatalogueItemCommand(createCatalogueItemCommand CreateCatalogueItemCommand) ApiApiCatalogueItemsCreatePostRequest {
	r.createCatalogueItemCommand = &createCatalogueItemCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiCatalogueItemsCreatePostRequest) XRemsApiKey(xRemsApiKey string) ApiApiCatalogueItemsCreatePostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiCatalogueItemsCreatePostRequest) XRemsUserId(xRemsUserId string) ApiApiCatalogueItemsCreatePostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiCatalogueItemsCreatePostRequest) Execute() (*CreateCatalogueItemResponse, *http.Response, error) {
	return r.ApiService.ApiCatalogueItemsCreatePostExecute(r)
}

/*
ApiCatalogueItemsCreatePost Create a new catalogue item (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiCatalogueItemsCreatePostRequest
*/
func (a *CatalogueItemsAPIService) ApiCatalogueItemsCreatePost(ctx context.Context) ApiApiCatalogueItemsCreatePostRequest {
	return ApiApiCatalogueItemsCreatePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CreateCatalogueItemResponse
func (a *CatalogueItemsAPIService) ApiCatalogueItemsCreatePostExecute(r ApiApiCatalogueItemsCreatePostRequest) (*CreateCatalogueItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateCatalogueItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogueItemsAPIService.ApiCatalogueItemsCreatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalogue-items/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCatalogueItemCommand == nil {
		return localVarReturnValue, nil, reportError("createCatalogueItemCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.createCatalogueItemCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiCatalogueItemsEditPutRequest struct {
	ctx                      context.Context
	ApiService               *CatalogueItemsAPIService
	editCatalogueItemCommand *EditCatalogueItemCommand
	xRemsApiKey              *string
	xRemsUserId              *string
}

func (r ApiApiCatalogueItemsEditPutRequest) EditCatalogueItemCommand(editCatalogueItemCommand EditCatalogueItemCommand) ApiApiCatalogueItemsEditPutRequest {
	r.editCatalogueItemCommand = &editCatalogueItemCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiCatalogueItemsEditPutRequest) XRemsApiKey(xRemsApiKey string) ApiApiCatalogueItemsEditPutRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiCatalogueItemsEditPutRequest) XRemsUserId(xRemsUserId string) ApiApiCatalogueItemsEditPutRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiCatalogueItemsEditPutRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiCatalogueItemsEditPutExecute(r)
}

/*
ApiCatalogueItemsEditPut Edit a catalogue item (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiCatalogueItemsEditPutRequest
*/
func (a *CatalogueItemsAPIService) ApiCatalogueItemsEditPut(ctx context.Context) ApiApiCatalogueItemsEditPutRequest {
	return ApiApiCatalogueItemsEditPutRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *CatalogueItemsAPIService) ApiCatalogueItemsEditPutExecute(r ApiApiCatalogueItemsEditPutRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogueItemsAPIService.ApiCatalogueItemsEditPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalogue-items/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.editCatalogueItemCommand == nil {
		return localVarReturnValue, nil, reportError("editCatalogueItemCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.editCatalogueItemCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiCatalogueItemsEnabledPutRequest struct {
	ctx            context.Context
	ApiService     *CatalogueItemsAPIService
	enabledCommand *EnabledCommand
	xRemsApiKey    *string
	xRemsUserId    *string
}

func (r ApiApiCatalogueItemsEnabledPutRequest) EnabledCommand(enabledCommand EnabledCommand) ApiApiCatalogueItemsEnabledPutRequest {
	r.enabledCommand = &enabledCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiCatalogueItemsEnabledPutRequest) XRemsApiKey(xRemsApiKey string) ApiApiCatalogueItemsEnabledPutRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiCatalogueItemsEnabledPutRequest) XRemsUserId(xRemsUserId string) ApiApiCatalogueItemsEnabledPutRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiCatalogueItemsEnabledPutRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ApiCatalogueItemsEnabledPutExecute(r)
}

/*
ApiCatalogueItemsEnabledPut Enable or disable catalogue item (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiCatalogueItemsEnabledPutRequest
*/
func (a *CatalogueItemsAPIService) ApiCatalogueItemsEnabledPut(ctx context.Context) ApiApiCatalogueItemsEnabledPutRequest {
	return ApiApiCatalogueItemsEnabledPutRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SuccessResponse
func (a *CatalogueItemsAPIService) ApiCatalogueItemsEnabledPutExecute(r ApiApiCatalogueItemsEnabledPutRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogueItemsAPIService.ApiCatalogueItemsEnabledPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalogue-items/enabled"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enabledCommand == nil {
		return localVarReturnValue, nil, reportError("enabledCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.enabledCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiCatalogueItemsGetRequest struct {
	ctx         context.Context
	ApiService  *CatalogueItemsAPIService
	xRemsApiKey *string
	xRemsUserId *string
	resource    *string
	expand      *string
	archived    *bool
	disabled    *bool
	expired     *bool
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiCatalogueItemsGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiCatalogueItemsGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiCatalogueItemsGetRequest) XRemsUserId(xRemsUserId string) ApiApiCatalogueItemsGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

// resource id (optional)
func (r ApiApiCatalogueItemsGetRequest) Resource(resource string) ApiApiCatalogueItemsGetRequest {
	r.resource = &resource
	return r
}

// expanded additional attributes (optional), can be \&quot;names\&quot;
func (r ApiApiCatalogueItemsGetRequest) Expand(expand string) ApiApiCatalogueItemsGetRequest {
	r.expand = &expand
	return r
}

// whether to include archived items
func (r ApiApiCatalogueItemsGetRequest) Archived(archived bool) ApiApiCatalogueItemsGetRequest {
	r.archived = &archived
	return r
}

// whether to include disabled items
func (r ApiApiCatalogueItemsGetRequest) Disabled(disabled bool) ApiApiCatalogueItemsGetRequest {
	r.disabled = &disabled
	return r
}

// whether to include expired items
func (r ApiApiCatalogueItemsGetRequest) Expired(expired bool) ApiApiCatalogueItemsGetRequest {
	r.expired = &expired
	return r
}

func (r ApiApiCatalogueItemsGetRequest) Execute() ([]CatalogueItem, *http.Response, error) {
	return r.ApiService.ApiCatalogueItemsGetExecute(r)
}

/*
ApiCatalogueItemsGet Get catalogue items (roles: logged-in)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiCatalogueItemsGetRequest
*/
func (a *CatalogueItemsAPIService) ApiCatalogueItemsGet(ctx context.Context) ApiApiCatalogueItemsGetRequest {
	return ApiApiCatalogueItemsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []CatalogueItem
func (a *CatalogueItemsAPIService) ApiCatalogueItemsGetExecute(r ApiApiCatalogueItemsGetRequest) ([]CatalogueItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CatalogueItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogueItemsAPIService.ApiCatalogueItemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalogue-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.resource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource", r.resource, "", "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "", "")
	}
	if r.disabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disabled", r.disabled, "", "")
	}
	if r.expired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expired", r.expired, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiCatalogueItemsItemIdChangeFormPostRequest struct {
	ctx               context.Context
	ApiService        *CatalogueItemsAPIService
	itemId            int64
	changeFormCommand *ChangeFormCommand
	xRemsApiKey       *string
	xRemsUserId       *string
}

func (r ApiApiCatalogueItemsItemIdChangeFormPostRequest) ChangeFormCommand(changeFormCommand ChangeFormCommand) ApiApiCatalogueItemsItemIdChangeFormPostRequest {
	r.changeFormCommand = &changeFormCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiCatalogueItemsItemIdChangeFormPostRequest) XRemsApiKey(xRemsApiKey string) ApiApiCatalogueItemsItemIdChangeFormPostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiCatalogueItemsItemIdChangeFormPostRequest) XRemsUserId(xRemsUserId string) ApiApiCatalogueItemsItemIdChangeFormPostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiCatalogueItemsItemIdChangeFormPostRequest) Execute() (*ChangeFormResponse, *http.Response, error) {
	return r.ApiService.ApiCatalogueItemsItemIdChangeFormPostExecute(r)
}

/*
ApiCatalogueItemsItemIdChangeFormPost Change catalogue item form. Creates a copy and ends the old. DEPRECATED, will disappear, use /update instead (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId catalogue item
	@return ApiApiCatalogueItemsItemIdChangeFormPostRequest
*/
func (a *CatalogueItemsAPIService) ApiCatalogueItemsItemIdChangeFormPost(ctx context.Context, itemId int64) ApiApiCatalogueItemsItemIdChangeFormPostRequest {
	return ApiApiCatalogueItemsItemIdChangeFormPostRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
	}
}

// Execute executes the request
//
//	@return ChangeFormResponse
func (a *CatalogueItemsAPIService) ApiCatalogueItemsItemIdChangeFormPostExecute(r ApiApiCatalogueItemsItemIdChangeFormPostRequest) (*ChangeFormResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ChangeFormResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogueItemsAPIService.ApiCatalogueItemsItemIdChangeFormPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalogue-items/{item-id}/change-form"
	localVarPath = strings.Replace(localVarPath, "{"+"item-id"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.changeFormCommand == nil {
		return localVarReturnValue, nil, reportError("changeFormCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.changeFormCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiCatalogueItemsItemIdGetRequest struct {
	ctx         context.Context
	ApiService  *CatalogueItemsAPIService
	itemId      int64
	xRemsApiKey *string
	xRemsUserId *string
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiCatalogueItemsItemIdGetRequest) XRemsApiKey(xRemsApiKey string) ApiApiCatalogueItemsItemIdGetRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiCatalogueItemsItemIdGetRequest) XRemsUserId(xRemsUserId string) ApiApiCatalogueItemsItemIdGetRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiCatalogueItemsItemIdGetRequest) Execute() (*CatalogueItem, *http.Response, error) {
	return r.ApiService.ApiCatalogueItemsItemIdGetExecute(r)
}

/*
ApiCatalogueItemsItemIdGet Get a single catalogue item

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId catalogue item
	@return ApiApiCatalogueItemsItemIdGetRequest
*/
func (a *CatalogueItemsAPIService) ApiCatalogueItemsItemIdGet(ctx context.Context, itemId int64) ApiApiCatalogueItemsItemIdGetRequest {
	return ApiApiCatalogueItemsItemIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
	}
}

// Execute executes the request
//
//	@return CatalogueItem
func (a *CatalogueItemsAPIService) ApiCatalogueItemsItemIdGetExecute(r ApiApiCatalogueItemsItemIdGetRequest) (*CatalogueItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CatalogueItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogueItemsAPIService.ApiCatalogueItemsItemIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalogue-items/{item-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"item-id"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiCatalogueItemsItemIdUpdatePostRequest struct {
	ctx                        context.Context
	ApiService                 *CatalogueItemsAPIService
	itemId                     int64
	updateCatalogueItemCommand *UpdateCatalogueItemCommand
	xRemsApiKey                *string
	xRemsUserId                *string
}

func (r ApiApiCatalogueItemsItemIdUpdatePostRequest) UpdateCatalogueItemCommand(updateCatalogueItemCommand UpdateCatalogueItemCommand) ApiApiCatalogueItemsItemIdUpdatePostRequest {
	r.updateCatalogueItemCommand = &updateCatalogueItemCommand
	return r
}

// REMS API-Key (optional for UI, required for API)
func (r ApiApiCatalogueItemsItemIdUpdatePostRequest) XRemsApiKey(xRemsApiKey string) ApiApiCatalogueItemsItemIdUpdatePostRequest {
	r.xRemsApiKey = &xRemsApiKey
	return r
}

// user (optional for UI, required for API). This can be a REMS internal or an external user identity attribute (specified in config.edn).
func (r ApiApiCatalogueItemsItemIdUpdatePostRequest) XRemsUserId(xRemsUserId string) ApiApiCatalogueItemsItemIdUpdatePostRequest {
	r.xRemsUserId = &xRemsUserId
	return r
}

func (r ApiApiCatalogueItemsItemIdUpdatePostRequest) Execute() (*UpdateCatalogueItemResponse, *http.Response, error) {
	return r.ApiService.ApiCatalogueItemsItemIdUpdatePostExecute(r)
}

/*
ApiCatalogueItemsItemIdUpdatePost Update a catalogue item allowing to change form and workflow. Creates a copy and ends the old. (roles: organization-owner, owner)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId catalogue item
	@return ApiApiCatalogueItemsItemIdUpdatePostRequest
*/
func (a *CatalogueItemsAPIService) ApiCatalogueItemsItemIdUpdatePost(ctx context.Context, itemId int64) ApiApiCatalogueItemsItemIdUpdatePostRequest {
	return ApiApiCatalogueItemsItemIdUpdatePostRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
	}
}

// Execute executes the request
//
//	@return UpdateCatalogueItemResponse
func (a *CatalogueItemsAPIService) ApiCatalogueItemsItemIdUpdatePostExecute(r ApiApiCatalogueItemsItemIdUpdatePostRequest) (*UpdateCatalogueItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateCatalogueItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogueItemsAPIService.ApiCatalogueItemsItemIdUpdatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalogue-items/{item-id}/update"
	localVarPath = strings.Replace(localVarPath, "{"+"item-id"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateCatalogueItemCommand == nil {
		return localVarReturnValue, nil, reportError("updateCatalogueItemCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/transit+msgpack", "application/transit+json", "application/edn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRemsApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-api-key", r.xRemsApiKey, "", "")
	}
	if r.xRemsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-rems-user-id", r.xRemsUserId, "", "")
	}
	// body params
	localVarPostBody = r.updateCatalogueItemCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
